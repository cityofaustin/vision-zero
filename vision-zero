#!/usr/bin/env python
import argparse
from datetime import date, datetime
import os
import shutil
import subprocess
import time

from dotenv import load_dotenv
import requests
import shtab

GRAPHQL_ENGINE_PORT = 8084

# check if the .env file exists
if not os.path.exists(".env"):
    print("No .env file found. Please copy env_template to .env and update the values.")
    exit()

load_dotenv()

TABLES_TO_IGNORE = [
    "public.change_log_crashes",
    "public.change_log_crashes_cris",
    "public.change_log_units_cris",
    "public.change_log_people_cris",
    "public.change_log_people",
    "public.change_log_units",
    "public.change_log_ems__incidents",
    "public.location_crashes_view",
]


def checkDockerComposeAvailability():
    docker_compose_stand_alone = False  # old docker-compose
    docker_compose_bundled = False  # new docker compose
    try:
        docker_compose_stand_alone = shutil.which("docker-compose")
    except:
        pass

    try:
        subprocess.check_output("docker compose", stderr=subprocess.STDOUT, shell=True)
        docker_compose_bundled = True
    except:
        pass

    if docker_compose_bundled:
        print("Using `docker compose`")
        return ["docker", "compose"]
    elif docker_compose_stand_alone:
        print("Using `docker-compose`")
        return ["docker-compose"]
    elif not docker_compose_stand_alone and not docker_compose_bundled:
        print("Neither `docker-compose` nor `docker compose` is available.")
        exit()


def wait_for_hasura(max_attempts=3, delay=2):
    """Wait for Hasura to be ready by polling health endpoint"""
    for attempt in range(max_attempts):
        print("‚è≥ Waiting for GraphQL Engine to be ready...")
        try:
            response = requests.get(
                f"http://localhost:{GRAPHQL_ENGINE_PORT}/healthz", timeout=1
            )
            if response.status_code == 200:
                print("‚úÖ GraphQL Engine is ready!")
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(delay)

    print("‚ùå GraphQL Engine failed to become ready")
    return False


def doCommand(args):
    apply_migrations = args.apply
    if args.command == "build":
        buildTools()
    elif args.command == "local-stack-up":
        dbUp()
        graphqlEngineUp(apply_migrations)
        cr3UserApiUp()
    elif args.command == "local-stack-down":
        cr3UserApiDown()
        graphqlEngineDown()
        dbDown()
    elif args.command == "db-up":
        dbUp()
    elif args.command == "db-down":
        dbDown()
    elif args.command == "graphql-engine-up":
        dbUp()
        graphqlEngineUp(apply_migrations)
    elif args.command == "graphql-engine-down":
        graphqlEngineDown()
    elif args.command == "api-up":
        cr3UserApiUp()
    elif args.command == "api-down":
        cr3UserApiDown()
    elif args.command == "hasura-console":
        hasuraConsole()
    elif args.command == "psql":
        psql()
    elif args.command == "tools-shell":
        dbUp()
        toolsShell()
    elif args.command == "stop":
        stop()
    elif args.command == "replicate-db":
        dbUp()
        replicateDb(args)
    elif args.command == "dump-local-db":
        dumpLocalDb()
    elif args.command == "remove-snapshots":
        removeSnapshots()


## function to list the files in a directory and delete them
def removeSnapshots():
    print("üóëÔ∏è  Removing snapshots")
    for f in os.listdir("database/snapshots/"):
        if not f.endswith(".sql"):
            continue
        print("Removing " + f)
        os.remove("database/snapshots/" + f)


# def replicateDb(includeChangeLogData=False):
def replicateDb(args):
    graphqlEngineDown()

    snapshotFilename = ""
    if args.filename:
        snapshotFilename = args.filename
    else:
        today = date.today().strftime("%Y-%m-%d")
        snapshotFilename = (
            "visionzero_"
            + today
            + "_"
            + (
                "with-change-log"
                if args.include_change_log_data
                else "without-change-log"
            )
            + ".sql"
        )

    snapshotFQP_complete = "database/snapshots/" + snapshotFilename
    snapshotFQP_in_progress = snapshotFQP_complete.replace(".sql", ".in_progress")
    snapshotFQP_error = snapshotFQP_complete.replace(".sql", ".error")

    # fmt: off
    replicate_runner_command = docker_compose_invocation + [
        "-f", "docker-compose.yml", 
        "run",
        "--rm",
        "-e", "PGHOST=" + os.environ["RR_HOSTNAME"],
        "-e", "PGDATABASE=" + os.environ["RR_DATABASE"],
        "-e", "PGUSER=" + os.environ["RR_USERNAME"],
        "-e", "PGPASSWORD=" + os.environ["RR_PASSWORD"],
        "postgis",
    ]

    replicate_command = [
        "pg_dump",
        "--clean",
        "--create",
        "--no-owner",
        "--no-privileges",
        "--if-exists",
        "--exclude-schema=import*"
        #"--table", "atd_txdot__airbag_lkp",
        #"-t", "atd_txdot_crashes",
    ]
    if not args.include_change_log_data:
        for t in TABLES_TO_IGNORE:
            replicate_command.append("--exclude-table-data")
            replicate_command.append(t)

    postgres_db_runner_command = docker_compose_invocation + [
        "-f", "docker-compose.yml", 
        "run",
        "--rm",
        "-e", "PGHOST=" + 'postgis',
        "-e", "PGUSER=" + os.environ["POSTGRES_USER"],
        "-e", "PGPASSWORD=" + os.environ["POSTGRES_PASSWORD"],
        "-e", "PGDATABASE=postgres",
        "postgis",
    ]
    
    if not (os.path.exists(snapshotFQP_complete)):
        print("Ô∏èüóÑ  Downloading remote database")
        if args.include_change_log_data:
            print("This will take a while, on the order of half an hour.")
        else:
            print("This can take up to 15 minutes.")
        print(" ".join(replicate_runner_command) + " " + " ".join(replicate_command))
        snapshot = open(snapshotFQP_in_progress, "w")

        try:
            result = subprocess.run(
                replicate_runner_command + replicate_command,
                stdout=snapshot,
            )
        except Exception as e:
            # rename the corrupted snapshot
            os.rename(snapshotFQP_in_progress, snapshotFQP_error)
            raise e

        if result.returncode != 0:
            print(f"‚ùå pg_dump failed with return code {result.returncode}")
            print(f"Error output: {result.stderr}")
            # rename the corrupted snapshot
            os.rename(snapshotFQP_in_progress, snapshotFQP_error)
            snapshot.close()
            exit(1)
        else:
            os.rename(snapshotFQP_in_progress, snapshotFQP_complete)
            snapshot.close()
            print("‚úÖ Database dump completed successfully")

    drop_database_command = [
        "psql",
        "--command=DROP DATABASE IF EXISTS "
        + os.environ["POSTGRES_DB"]
        + " WITH(force)",
    ]

    print("Ô∏èü´≥ Dropping the local database")
    print(" ".join(postgres_db_runner_command) + " " + " ".join(drop_database_command))
    subprocess.run(postgres_db_runner_command + drop_database_command)

    populate_command = [
        "bash",
        "-c",
        "cat /snapshots/"
        + snapshotFilename
        + " | \
        perl -pe 's/^(SELECT pg_catalog\.set_config)/-- $1/g' | \
        psql -v ON_ERROR_STOP=1",
    ]

    print("Ô∏èüèóÔ∏è Loading the database with snapshot")
    print(" ".join(postgres_db_runner_command) + " " + " ".join(populate_command))
    result = subprocess.run(postgres_db_runner_command + populate_command)
    if result.returncode != 0:
        print(
            f"‚ùå Failed to load database from snapshot: return code {result.returncode}"
        )
        print(f"Error output: {result.stderr}")
        exit(1)

    graphqlEngineUp(args.apply)


def dumpLocalDb():
    print("Ô∏èDumping local database")
    today = datetime.now().strftime("%Y-%m-%d-%H-%M:%S")

    dump_runner_command = docker_compose_invocation + [
        "-f",
        "docker-compose.yml",
        "run",
        "--rm",
        "-e",
        "PGHOST=" + "postgis",
        "-e",
        "PGUSER=" + os.environ["POSTGRES_USER"],
        "-e",
        "PGPASSWORD=" + os.environ["POSTGRES_PASSWORD"],
        "-e",
        "PGDATABASE=" + os.environ["POSTGRES_DB"],
        "postgis",
    ]

    dump_command = [
        "pg_dump",
        "--clean",
        "--create",
        "--no-owner",
        "--no-privileges",
        "--if-exists",
    ]

    dump = open("database/dumps/visionzero_" + today + ".sql", "w")
    subprocess.run(dump_runner_command + dump_command, stdout=dump)
    dump.close()


def psql():
    # fmt: off
    db_tools_runner_command = docker_compose_invocation + [
        "-f", "docker-compose.yml", 
        "run",
        "--rm",
        "-e", "PGHOST=postgis",
        "-e", "PGDATABASE=" + os.environ["POSTGRES_DB"],
        "-e", "PGUSER=" + os.environ["POSTGRES_USER"],
        "-e", "PGPASSWORD=" + os.environ["POSTGRES_PASSWORD"],
        "postgis",
    ]
    # fmt: on

    print("üì∫  Starting psql")
    subprocess.run(db_tools_runner_command + ["psql"])


def buildTools():
    print("üõ†Ô∏è  Rebuilding images with --no-cache -q")
    subprocess.run(
        docker_compose_invocation
        + [
            "-f",
            "docker-compose.yml",
            "build",
            "--no-cache",
        ]
    )


def dbUp():
    print("üõ¢Ô∏è  Starting database")
    result = subprocess.run(
        docker_compose_invocation
        + [
            "-f",
            "docker-compose.yml",
            "up",
            "-d",
            "postgis",
        ]
    )
    if result.returncode != 0:
        print(f"‚ùå database startup failed with return code {result.returncode}")
        print(f"Error output: {result.stderr}")
        exit(1)
    subprocess.run(["docker", "ps"])


def dbDown():
    graphqlEngineDown()
    print("üõ¢Ô∏è  Stopping database")
    subprocess.run(
        docker_compose_invocation
        + [
            "-f",
            "docker-compose.yml",
            "stop",
            "postgis",
        ]
    )
    subprocess.run(["docker", "ps"])


def graphqlEngineUp(apply_migrations=False):
    print("üöÄ  Starting GraphQL Engine")
    subprocess.run(
        docker_compose_invocation
        + [
            "-f",
            "docker-compose.yml",
            "up",
            "-d",
            "graphql-engine",
        ]
    )

    if apply_migrations:
        if wait_for_hasura():
            subprocess.call(
                [
                    "hasura",
                    "migrate",
                    "apply",
                    "--all-databases",
                    "--disable-interactive",
                ],
                cwd="./database",
            )
            subprocess.call(
                ["hasura", "metadata", "apply"],
                cwd="./database",
            )

    subprocess.run(["docker", "ps"])
    print("üöÄ  GraphQL Engine started.")
    print("You can run './vision-zero hasura-console' to open the console.")


def cr3UserApiUp():
    print("üöÄ  Starting Flask API")
    subprocess.run(
        docker_compose_invocation
        + [
            "-f",
            "docker-compose.yml",
            "up",
            "-d",
            "cr3-user-api",
        ]
    )
    subprocess.run(["docker", "ps"])
    print("üöÄ  CR3 / User flask API started.")


def cr3UserApiDown():
    print("üõë Stopping Flask API")
    subprocess.run(
        docker_compose_invocation
        + [
            "-f",
            "docker-compose.yml",
            "stop",
            "cr3-user-api",
        ]
    )
    subprocess.run(["docker", "ps"])
    print("üöÄ  CR3 / User flask API stopped.")


def hasuraConsole():
    print("üöÄ  Opening Hasura console")
    try:
        subprocess.call(
            ["hasura", "console", "--console-port", "9696"], cwd="./database"
        )
    except KeyboardInterrupt:
        print("Exited Hasura console")


def graphqlEngineDown():
    print("üöÄ  Stopping GraphQL Engine")
    subprocess.run(
        docker_compose_invocation
        + [
            "-f",
            "docker-compose.yml",
            "stop",
            "graphql-engine",
        ]
    )
    subprocess.run(["docker", "ps"])


def toolsShell():
    print("üêö  Starting tools shell")

    # fmt: off
    tool_runner_command = docker_compose_invocation + [
        "-f", "docker-compose.yml", 
        "run",
        "--rm",
        "-e", "PGHOST=" + "postgis",
        "-e", "PGUSER=" + os.environ["POSTGRES_USER"],
        "-e", "PGPASSWORD=" + os.environ["POSTGRES_PASSWORD"],
        "-e", "PGDATABASE=" + os.environ["POSTGRES_DB"],
        "postgis",
    ]
    # fmt: on

    shell_command = ["bash"]
    subprocess.run(tool_runner_command + shell_command)


def stop():
    print("üõë  Stopping containers")
    subprocess.run(
        docker_compose_invocation
        + [
            "-f",
            "docker-compose.yml",
            "stop",
        ]
    )


def get_main_parser():
    parser = argparse.ArgumentParser(prog="vision-zero")
    # ü™Ñ generate a autocompletion script for the shell
    shtab.add_argument_to(parser, ["-s", "--print-completion"])
    parser.add_argument("-c", "--include-change-log-data", action="store_true")
    parser.add_argument(
        "command",
        choices=[
            "build",
            "local-stack-up",
            "local-stack-down",
            "db-up",
            "db-down",
            "api-up",
            "api-down",
            "graphql-engine-up",
            "graphql-engine-down",
            "stop",
            "psql",
            "tools-shell",
            "replicate-db",
            "dump-local-db",
            "remove-snapshots",
            "hasura-console",
        ],
    )
    parser.add_argument("-f", "--filename", required=False)
    parser.add_argument(
        "-a",
        "--apply",
        action="store_true",
        help="Apply migrations and metadata after starting",
    )
    return parser


if __name__ == "__main__":
    parser = get_main_parser()
    args = parser.parse_args()
    docker_compose_invocation = checkDockerComposeAvailability()  # global .. üëé
    doCommand(args)
